<!doctype html>
<!--
ナット溝位置計算 / テンプレ・STL生成ツール
Nut Slot Calculator / Template & STL Generator

Copyright (c) 2026 es craft LLC

Version : 1.0.0
Release : 2026-02-11

==================================================
【利用許諾 / LICENSE TERMS】
==================================================

【日本語】

本ソフトウェアおよび本ソフトウェアから生成されるすべてのデータ
（PDF、印刷テンプレート、画像、STL ファイル等を含みます）は、
以下の条件に同意した場合のみ利用できます。

- 利用範囲：
  個人使用に限り自由とします。

- 再配布：
  禁止。
  本ソフトウェアおよび生成物を、改変の有無を問わず第三者へ
  配布、公開、共有することを禁止します。

- 生成物の販売：
  禁止。
  STL、PDF、テンプレート、またはそれらを元にしたデータを
  販売、有償提供、または商業的に利用することを禁止します。

- 商用利用：
  禁止。
  業務利用、受託制作、製品への利用等の商業目的での使用を禁止します。

- 免責：
  本ソフトウェアの利用はすべて利用者の自己責任とします。
  寸法精度、加工結果、破損、事故、損害等について、
  制作者および es craft LLC は一切の責任を負いません。

※ 上記条件の例外は、es craft LLC による事前の書面許可がある場合のみ認められます。


--------------------------------------------------

【English】

This software and all data generated by it (including but not limited to
PDF files, printed templates, images, and STL files) may be used ONLY
under the following conditions:

- Permitted Use:
  Free for personal, non-commercial use only.

- Redistribution:
  Prohibited.
  Redistribution or public sharing of this software or any generated data,
  whether modified or unmodified, is strictly prohibited.

- Sale of Generated Data:
  Prohibited.
  Selling, licensing, or otherwise commercially distributing any generated
  data (including PDF, STL, templates, or derivative data) is not allowed.

- Commercial Use:
  Prohibited.
  Use in any commercial, professional, or business context is not permitted,
  including but not limited to commissioned work or product manufacturing.

- Disclaimer:
  This software is provided "as is" and is used entirely at the user's own risk.
  The author and es craft LLC assume no responsibility or liability for
  measurement accuracy, manufacturing results, damage, loss, or any
  consequential issues arising from its use.

Exceptions to the above terms are permitted only with prior written
authorization from es craft LLC.
-->
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ナット溝位置計算（PDF / STL：コーム＋ガイドナット）</title>
  <style>
    *,*::before,*::after{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,"Segoe UI",sans-serif;margin:24px;line-height:1.5}
    label{display:block;margin:10px 0 4px}
    input,textarea,select{width:100%;max-width:980px;padding:10px;font-size:16px}
    button{padding:10px 14px;font-size:16px;margin:8px 8px 0 0;cursor:pointer}
    pre{background:#f6f6f6;padding:12px;max-width:980px;overflow:auto}
    .row{display:flex;gap:12px;flex-wrap:wrap;max-width:980px}
    .row > div{flex:1;min-width:240px}
    small{color:#444}
    .panel{border:1px solid #ddd;border-radius:12px;padding:12px;max-width:980px}
    .subpanel{border:1px solid #eee;border-radius:12px;padding:12px;margin-top:12px}
    #templateWrap{max-width:980px; overflow:auto; border:1px dashed #bbb; border-radius:12px; padding:12px; background:#fff}
    .muted{color:#666}
    .hint{background:#fff8e6;border:1px solid #f3d37a;padding:10px;border-radius:10px;max-width:980px}
    .btnrow{display:flex;flex-wrap:wrap;gap:8px}
  </style>
</head>
<footer style="max-width:980px;margin-top:18px;color:#666;font-size:12px">
  © 2026 es craft LLC / 個人使用に限り自由 / 再配布禁止 / 生成物販売禁止
</footer>
<body>
  <h1>ナット溝位置計算（外周間隔一定 / PDFテンプレ / STL出力）</h1>

  <div class="panel">

    <div class="row">
      <div>
        <label>ナット幅 W (mm)</label>
        <input id="W" type="number" step="0.01" value="42.20">
      </div>
    </div>

    <div class="row">
      <div>
        <label>低音側（左端）余白 mL：端〜低音側外弦「外周」まで (mm)</label>
        <input id="mL" type="number" step="0.01" value="3.30">
      </div>
      <div>
        <label>高音側（右端）余白 mR：端〜高音側外弦「外周」まで (mm)</label>
        <input id="mR" type="number" step="0.01" value="3.30">
      </div>
    </div>

    <div class="subpanel">
      <b>弦プリセット</b>
      <div class="row">
        <div>
          <label>プリセット選択</label>
          <select id="preset">
            <option value="">（手入力）</option>
            <option value="g09_42">ギター 09–42</option>
            <option value="g10_46">ギター 10–46</option>            
            <option value="b45_100">ベース 45–100</option>
            <option value="b50_105">ベース 50–105</option>
          </select>
          <small>選ぶと下の弦径欄に自動反映（低音→高音）</small>
        </div>
        <div>
          <label>プリセットを適用</label>
          <button id="btnApplyPreset">弦径へ反映</button>
          <small class="muted">反映後に手で編集してOK</small>
        </div>
      </div>
    </div>

    <label>弦径 d（カンマ区切り / 低音→高音）</label>
    <textarea id="ds" rows="2">.046,.036,.026,.017,.013,.010</textarea>
    <small>
      入力順は「低音→高音」。表示は「1弦=高音側」。<br>
      入力は mm でも inch でもOK。1.0以下が含まれる場合 inch とみなし mm に変換（×25.4）
    </small>

    <!-- STL: コーム -->
    <div class="subpanel">
      <b>STL：コーム（罫書き治具）</b>
      <div class="row">
        <div>
          <label>指板R (mm)</label>
          <input id="fbR" type="number" step="0.1" value="254">
          <small>例：9.5"≒241.3 / 10"≒254 / 12"≒304.8</small>
        </div>
        <div>
          <label>厚み t (mm)（中央最小厚）</label>
          <input id="combThk" type="number" step="0.1" value="2.0">
        </div>
      </div>
      <div class="row">
        <div>
          <label>コーム全長 L (mm)</label>
          <input id="combL" type="number" step="0.1" value="35">
        </div>
        <div>
          <label>スリット長さ Nd (mm)（前縁から奥行）</label>
          <input id="notchD" type="number" step="0.1" value="12">
        </div>
      </div>
      <div class="row">
        <div>
          <label>スリット幅 Sw (mm)</label>
          <input id="slotW" type="number" step="0.01" value="0.50">
        </div>
        <div>
          <label>STL分割ピッチ dx (mm)</label>
          <input id="dx" type="number" step="0.1" value="0.5">
        </div>
      </div>
    </div>

    <!-- STL: ガイド溝ナット -->
    <div class="subpanel">
      <b>STL：ガイド溝入りナット（深溝対応：幅=弦径、底R=弦半径）</b>

      <div class="row">
        <div>
          <label>ナット奥行 D (mm)</label>
          <input id="nutD" type="number" step="0.1" value="3.3">
        </div>
        <div>
          <label>ナット高さ H (mm)（中央厚み）</label>
          <input id="nutH" type="number" step="0.1" value="6.0">
        </div>
      </div>

      <div class="row">
        <div>
          <label>上面（弦側）形状</label>
          <select id="topMode">
            <option value="radius" selected>R</option>
            <option value="flat">フラット</option>
          </select>
        </div>
        <div>
          <label>上面R (mm)</label>
          <input id="topR" type="number" step="0.1" value="254">
        </div>
      </div>

      <div class="row">
        <div>
          <label>底面（指板側）形状</label>
          <select id="bottomMode">
            <option value="radius" selected>R（指板R）</option>
            <option value="flat">フラット</option>
          </select>
        </div>
        <div>
          <label>底面R (mm)</label>
          <input id="bottomR" type="number" step="0.1" value="254">
        </div>
      </div>

      <div class="row">
        <div>
          <label>前縁 面取り C_front (mm)</label>
          <input id="cFront" type="number" step="0.1" value="0.1">
        </div>
        <div>
          <label>後縁 面取り C_back (mm)</label>
          <input id="cBack" type="number" step="0.1" value="0.3">
        </div>
      </div>
      <small>面取りは「上面側の前後エッジ」を45°で落とします（欠け防止）。</small>

      <div class="row">
        <div>
          <label>溝深さ gDepth (mm)（一括）</label>
          <input id="gDepth" type="number" step="0.05" value="1.20">
          <small>
            溝断面は「幅=弦径（一定）」「底R=弦半径（一定）」。<br>
            gDepthが弦半径より浅い場合は、溝幅を維持できないので自動で弦半径まで補正します。
          </small>
        </div>
        <div>
          <label>STL分割ピッチ dx (mm)（ナット用：x/y）</label>
          <input id="nutDx" type="number" step="0.1" value="0.4">
        </div>
      </div>

      <small>溝は「前縁→後縁へ一直線（ナット奥行方向）」です。</small>
    </div>

    <div class="btnrow">
      <button id="btnCalc">計算</button>
      <button id="btnPDF">PDF出力（印刷→PDF保存）</button>
      <button id="btnSTLComb">STL出力（コーム）</button>
      <button id="btnSTLNut">STL出力（ガイド溝ナット）</button>
    </div>

    <div class="hint" style="margin-top:10px">
      <b>PDF/印刷は必ず「100%（実際のサイズ）」</b>、<b>「ページに合わせる」はOFF</b>。<br>
      テンプレ内の<b>100mm検尺バー</b>が100.0mmになることを確認してください。
    </div>
  </div>

  <h2>結果</h2>
  <pre id="out">未計算</pre>

  <h2>1:1 印刷テンプレ</h2>
  <div id="templateWrap"><div class="muted">未計算</div></div>

<script>
(() => {
  "use strict";

  const $ = (id) => document.getElementById(id);
  const mm2 = (n) => Number(n).toFixed(2);

  let last = null; // { W,mL,mR,d,x,meta,svg }

  /* ===================== presets ===================== */
  const PRESETS = {
    g10_46: { name: "ギター 10–46", text: ".046,.036,.026,.017,.013,.010" },
    g09_42: { name: "ギター 09–42", text: ".042,.032,.024,.016,.011,.009" },
    b45_100:{ name: "ベース 45–100", text: ".100,.080,.065,.045" },
    b50_105:{ name: "ベース 50–105", text: ".105,.085,.070,.050" },
  };
  function applyPreset(){
    const key = $("preset").value;
    if(!key) return;
    $("ds").value = PRESETS[key].text;
  }

  /* ===================== parsing & spacing ===================== */
  function splitTokens(text){
    return text.split(/[\s,]+/).map(s=>s.trim()).filter(Boolean);
  }

  function parseDiametersWithMeta(text){
    const tokens = splitTokens(text);
    if(tokens.length < 2) throw new Error("弦径は2本以上入力してください。");
    const nums = tokens.map(t => Number(t));
    if(nums.some(n => !isFinite(n) || n <= 0)) throw new Error("弦径に数値以外、または0以下が含まれています。");
    const isInch = nums.some(n => n <= 1.0);
    const mm = nums.map(n => isInch ? n * 25.4 : n);
    return { mm, isInchInput: isInch, rawTokens: tokens };
  }

  function computeLayout(W, mL, mR, d){
    const n = d.length;
    const d1 = d[0], dn = d[n-1];
    const x1 = mL + d1/2;
    const xn = W - mR - dn/2;
    const span = xn - x1;
    if(span <= 0) throw new Error("WとmL/mRの関係が不正です（外側弦の中心間スパンが0以下）。");

    let sumMid = 0;
    for(let i=1;i<n-1;i++) sumMid += d[i];

    const g = ( span - ( (d1 + dn)/2 + sumMid ) ) / (n - 1);
    if(g < 0) throw new Error("指定条件では成立しません（g<0）。mL/mRを減らすかWを増やしてください。");

    const x = new Array(n);
    x[0] = x1;
    for(let i=0;i<n-1;i++){
      x[i+1] = x[i] + d[i]/2 + g + d[i+1]/2;
    }
    return { x, g, x1, xn, err: x[n-1]-xn };
  }

  function displayNo(i, n){ return n - i; }

  /* ===================== PDF template SVG ===================== */
  function pickCols(n){ return (n >= 8) ? 3 : 2; }

  function buildTemplateSVG(W, mL, mR, d, x, meta){
    const n = d.length;

    const scaleBarX = 10, scaleBarLen = 100, minWidthForScale = scaleBarX + scaleBarLen + 12;
    const padForNut = 30;
    const width = Math.max(W + padForNut*2, minWidthForScale);

    const yScaleText = 10, yScaleLine = 14;
    const yTitle1 = 30, yTitle2 = 38;

    const yTickTop = 48, yTickBot = 86, yNutLine = 66;
    const yNum = yTickTop - 4, fsNum = 2.6;

    const yEdge1 = 96, yEdge2 = 106;
    const yTableTitle = 118, yTableTop = 128;

    const fsTitle = 3.4, fs = 3.0;

    const cols = pickCols(n);
    const rows = Math.ceil(n / cols);
    const rowH = 7.0;
    const height = Math.max(150, yTableTop + rows*rowH + 14);

    const nutLeftX = (width - W) / 2;
    const nutRightX = nutLeftX + W;
    const X = x.map(v => nutLeftX + v);

    const leftEdge  = x[0] - d[0]/2;
    const rightEdge = W - (x[n-1] + d[n-1]/2);

    const colX = [];
    for(let c=0;c<cols;c++) colX.push(10 + c*(width/cols));

    const order = [];
    for(let i=n-1;i>=0;i--) order.push(i);

    function label(i){
      const disp = displayNo(i,n);
      if(meta.isInchInput){
        const raw = meta.rawTokens[i] || "";
        return `${disp}: d=${mm2(d[i])}mm (${raw}")  x=${mm2(x[i])}`;
      }
      return `${disp}: d=${mm2(d[i])}mm  x=${mm2(x[i])}`;
    }

    let s = "";
    s += `<svg xmlns="http://www.w3.org/2000/svg" width="${width}mm" height="${height}mm" viewBox="0 0 ${width} ${height}">`;
    s += `<rect x="0" y="0" width="${width}" height="${height}" fill="white"/>`;

    s += `<text x="${scaleBarX}" y="${yScaleText}" font-size="${fs}" font-family="system-ui, sans-serif">100mm 検尺（定規で100.0mmになること）</text>`;
    s += `<line x1="${scaleBarX}" y1="${yScaleLine}" x2="${scaleBarX+scaleBarLen}" y2="${yScaleLine}" stroke="black" stroke-width="0.4"/>`;
    s += `<line x1="${scaleBarX}" y1="${yScaleLine-2.2}" x2="${scaleBarX}" y2="${yScaleLine+2.2}" stroke="black" stroke-width="0.4"/>`;
    s += `<line x1="${scaleBarX+scaleBarLen}" y1="${yScaleLine-2.2}" x2="${scaleBarX+scaleBarLen}" y2="${yScaleLine+2.2}" stroke="black" stroke-width="0.4"/>`;

    s += `<text x="10" y="${yTitle1}" font-size="${fsTitle}" font-family="system-ui, sans-serif">Nut W=${mm2(W)}mm</text>`;
    s += `<text x="10" y="${yTitle2}" font-size="${fsTitle}" font-family="system-ui, sans-serif">mL=${mm2(mL)} / mR=${mm2(mR)}（端〜外周）</text>`;

    s += `<line x1="${nutLeftX}" y1="${yNutLine}" x2="${nutRightX}" y2="${yNutLine}" stroke="black" stroke-width="0.7"/>`;
    s += `<line x1="${nutLeftX}" y1="${yNutLine-12}" x2="${nutLeftX}" y2="${yNutLine+16}" stroke="black" stroke-width="0.7"/>`;
    s += `<line x1="${nutRightX}" y1="${yNutLine-12}" x2="${nutRightX}" y2="${yNutLine+16}" stroke="black" stroke-width="0.7"/>`;

    for(let i=0;i<n;i++){
      const cx = X[i];
      s += `<line x1="${cx}" y1="${yTickTop}" x2="${cx}" y2="${yTickBot}" stroke="black" stroke-width="0.35"/>`;
      s += `<text x="${cx}" y="${yNum}" text-anchor="middle" font-size="${fsNum}" font-family="ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace">${displayNo(i,n)}</text>`;
    }

    s += `<text x="10" y="${yEdge1}" font-size="${fs}" font-family="system-ui, sans-serif">L edge-to-string = ${mm2(leftEdge)}mm</text>`;
    s += `<text x="10" y="${yEdge2}" font-size="${fs}" font-family="system-ui, sans-serif">R edge-to-string = ${mm2(rightEdge)}mm</text>`;

    s += `<text x="10" y="${yTableTitle}" font-size="${fs}" font-family="system-ui, sans-serif">各弦（1弦=高音側）：番号 / 太さ / 中心x（mm）</text>`;

    for(let k=0;k<order.length;k++){
      const i = order[k];
      const c = k % cols;
      const r = Math.floor(k / cols);
      const y = yTableTop + r*rowH;
      s += `<text x="${colX[c]}" y="${y}" font-size="${fs}" font-family="ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace">${label(i)}</text>`;
    }

    s += `<text x="10" y="${height-6}" font-size="${fs}" font-family="system-ui, sans-serif">印刷設定：100%（拡大/縮小OFF）。検尺100mm→OKなら使用。</text>`;
const wm = `escraft|v1.0.0|2026-02-11|personal-use-only|no-redistribution|no-sale`;
s += `<text x="${width-1}" y="${height-1}"
  font-size="0.8"
  fill="#fefefe"
  font-family="ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace"
  text-anchor="end"
  dominant-baseline="ideographic"
  transform="rotate(-12 ${width-1} ${height-1})">
  ${wm}
</text>`;

    s += `</svg>`;
    return s;
  }

  /* ===================== STL helpers ===================== */
  function tri(a,b,c){
    const ux=b.x-a.x, uy=b.y-a.y, uz=b.z-a.z;
    const vx=c.x-a.x, vy=c.y-a.y, vz=c.z-a.z;
    const nx = uy*vz - uz*vy;
    const ny = uz*vx - ux*vz;
    const nz = ux*vy - uy*vx;
    const nl = Math.hypot(nx,ny,nz) || 1;
    const nnx = nx/nl, nny = ny/nl, nnz = nz/nl;
    return `facet normal ${nnx} ${nny} ${nnz}
outer loop
vertex ${a.x} ${a.y} ${a.z}
vertex ${b.x} ${b.y} ${b.z}
vertex ${c.x} ${c.y} ${c.z}
endloop
endfacet\n`;
  }

  function quad(tris, p00,p10,p11,p01){
    tris.push(tri(p00,p10,p11));
    tris.push(tri(p00,p11,p01));
  }

  function downloadText(filename, text){
    const blob = new Blob([text], {type:"text/plain"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function uniqSorted(arr){
    return Array.from(new Set(arr)).sort((a,b)=>a-b);
  }

  function refine1D(points, dMax){
    const p = uniqSorted(points);
    const out = [];
    for(let i=0;i<p.length-1;i++){
      const a = p[i], b = p[i+1];
      out.push(a);
      const len = b - a;
      const steps = Math.max(1, Math.ceil(len / dMax));
      for(let k=1;k<steps;k++) out.push(a + len*(k/steps));
    }
    out.push(p[p.length-1]);
    return uniqSorted(out);
  }

  function sagitta(dx, R){
    const t = R*R - dx*dx;
    if(t <= 0) return R;
    return R - Math.sqrt(t);
  }

  /* ===================== STL: comb ===================== */
  function zBottomComb(x, W, R, tMin){
    const cx = W/2;
    const s = sagitta(x - cx, R);
    return -(tMin + s);
  }

  function yMinAt(x, notches){
    for(const nt of notches){
      if(x >= nt.a && x <= nt.b) return nt.depth;
    }
    return 0;
  }

  function generateCombSTL({W, L, R, tMin, notchDepth, slotW, dxMax, xCenters}){
    if(!(R > W/2)) throw new Error("指板Rが小さすぎます（R > W/2 が必要）。");
    if(!(L > 0)) throw new Error("コーム全長Lが不正です。");
    if(!(notchDepth >= 0 && notchDepth <= L)) throw new Error("スリット長さNdが不正です（0〜L）。");
    if(!(slotW > 0)) throw new Error("スリット幅Swが不正です。");
    if(!(dxMax > 0.05)) throw new Error("dxは0.05mm以上推奨。");

    const notches = [];
    for(const xc of xCenters){
      const a = Math.max(0, xc - slotW/2);
      const b = Math.min(W, xc + slotW/2);
      if(b > a) notches.push({a,b,depth:notchDepth});
    }

    let xs = [0, W];
    for(const nt of notches){ xs.push(nt.a, nt.b); }
    xs = refine1D(xs, dxMax);

    const tris = [];
    const name = "nut_comb_v1_0_0_c2026_es_craft_personal_use_only_no_redistribution";


    for(let i=0;i<xs.length-1;i++){
      const x0 = xs[i], x1 = xs[i+1];
      const xm = (x0+x1)/2;
      const y0 = yMinAt(xm, notches);
      const y1 = L;

      const z0b = zBottomComb(x0, W, R, tMin);
      const z1b = zBottomComb(x1, W, R, tMin);

      quad(tris, {x:x0,y:y0,z:0},{x:x1,y:y0,z:0},{x:x1,y:y1,z:0},{x:x0,y:y1,z:0});
      quad(tris, {x:x0,y:y1,z:z0b},{x:x1,y:y1,z:z1b},{x:x1,y:y0,z:z1b},{x:x0,y:y0,z:z0b});
      quad(tris, {x:x0,y:y1,z:0},{x:x1,y:y1,z:0},{x:x1,y:y1,z:z1b},{x:x0,y:y1,z:z0b});
      quad(tris, {x:x1,y:y0,z:0},{x:x0,y:y0,z:0},{x:x0,y:y0,z:z0b},{x:x1,y:y0,z:z1b});
    }

    function capAtX(xCap){
      const zc = zBottomComb(xCap, W, R, tMin);
      const yMin = yMinAt(xCap, notches);
      quad(tris, {x:xCap,y:yMin,z:0},{x:xCap,y:L,z:0},{x:xCap,y:L,z:zc},{x:xCap,y:yMin,z:zc});
      if(yMin > 0) quad(tris, {x:xCap,y:0,z:0},{x:xCap,y:yMin,z:0},{x:xCap,y:yMin,z:zc},{x:xCap,y:0,z:zc});
    }
    capAtX(0); capAtX(W);

    for(let i=0;i<xs.length-2;i++){
      const xB = xs[i+1];
      const xl = (xs[i]+xs[i+1])/2;
      const xr = (xs[i+1]+xs[i+2])/2;
      const yl = yMinAt(xl, notches);
      const yr = yMinAt(xr, notches);
      if(yl === yr) continue;
      const zB = zBottomComb(xB, W, R, tMin);
      const yC = Math.max(yl, yr);
      quad(tris, {x:xB,y:0,z:0},{x:xB,y:yC,z:0},{x:xB,y:yC,z:zB},{x:xB,y:0,z:zB});
    }

    let stl = `solid ${name}\n`;
    for(const f of tris) stl += f;
    stl += `endsolid ${name}\n`;
    return stl;
  }

  /* ===================== STL: guide slotted nut (deep slot, width=dia, bottomR=dia/2) ===================== */
  function zBottomNut(x, W, H, bottomMode, bottomR){
    if(bottomMode === "flat") return -H;
    const cx = W/2;
    const s = sagitta(x - cx, bottomR);
    return -(H + s);
  }

  function zTopNutBase(x, W, topMode, topR){
    if(topMode === "flat") return 0;
    const cx = W/2;
    const s = sagitta(x - cx, topR);
    return -s;
  }

  function chamferDeltaTop(y, D, C_front, C_back){
    let d = 0;
    if(C_front > 0 && y >= 0 && y < C_front){
      d = Math.max(d, C_front - y);
    }
    if(C_back > 0 && y <= D && y > D - C_back){
      d = Math.max(d, C_back - (D - y));
    }
    return d;
  }

  // 深溝対応：
  // 断面は「幅=2r固定」＋「底は半円（R=r）」＋「上は縦壁」
  // totalDepth = max(gDepth, r)  ※幅固定を守るため、r未満はrに補正
  // 壁高さ h = totalDepth - r
  // |dx|<=r なら z = -(h + sqrt(r^2 - dx^2))  （dx=rで -h、dx=0で -(h+r)= -totalDepth）
  // |dx|>r なら z = 0（溝なし）
  function grooveZAtX_deepU(x, xCenters, dList, gDepth){
    let z = 0;
    for(let i=0;i<xCenters.length;i++){
      const xc = xCenters[i];
      const r  = dList[i] / 2;
      const totalDepth = Math.max(gDepth, r);
      const h = totalDepth - r;

      const dx = Math.abs(x - xc);
      if(dx > r) continue;

      const zg = -(h + Math.sqrt(Math.max(0, r*r - dx*dx))); // <= -h
      if(zg < z) z = zg;
    }
    return z;
  }

  function generateNutSTL({
    W, D, H,
    topMode, topR,
    bottomMode, bottomR,
    C_front, C_back,
    xCenters, dList,
    gDepth,
    dxy
  }){
    if(!(W > 0 && D > 0 && H > 0)) throw new Error("W/D/H が不正です。");
    if(topMode === "radius" && !(topR > W/2)) throw new Error("上面Rが小さすぎます（R > W/2）。");
    if(bottomMode === "radius" && !(bottomR > W/2)) throw new Error("底面Rが小さすぎます（R > W/2）。");
    if(!(gDepth >= 0.05)) throw new Error("溝深さが小さすぎます。");
    if(!(dxy > 0.05)) throw new Error("dxは0.05mm以上推奨。");
    if(C_front < 0 || C_back < 0) throw new Error("面取り量が不正（0以上）。");
    if(C_front + C_back >= D) throw new Error("面取り量が大きすぎます（前後合計が奥行D以上）。");

    // xサンプル：端＋各溝の境界（xc±r）＋中心（xc）
    // ※縦壁（x=±r）の“崖”を綺麗に出すため、xc±r は必ず入れる
    let xs = [0, W];
    for(let i=0;i<xCenters.length;i++){
      const xc = xCenters[i];
      const r  = dList[i] / 2;
      xs.push(xc, xc - r, xc + r);
    }
    xs = xs.map(v => Math.max(0, Math.min(W, v)));
    xs = refine1D(xs, dxy);

    let ys = [0, D];
    if(C_front > 0) ys.push(C_front);
    if(C_back > 0) ys.push(D - C_back);
    ys = refine1D(ys, dxy);

    const zTop = Array.from({length: ys.length}, () => new Array(xs.length).fill(0));
    const zBot = Array.from({length: ys.length}, () => new Array(xs.length).fill(0));

    for(let j=0;j<ys.length;j++){
      const y = ys[j];
      const dCham = chamferDeltaTop(y, D, C_front, C_back);

      for(let i=0;i<xs.length;i++){
        const x = xs[i];

        const zBaseTop = zTopNutBase(x, W, topMode, topR) - dCham;

        // 深溝U：ベース上面に「ローカル溝形状（0〜負）」を足す
        const zgLocal = grooveZAtX_deepU(x, xCenters, dList, gDepth) - dCham;
        const zGroove = zBaseTop + zgLocal;

        zTop[j][i] = Math.min(zBaseTop, zGroove);
        zBot[j][i] = zBottomNut(x, W, H, bottomMode, bottomR);
      }
    }

    const tris = [];
    const name = "guide_nut_v1_0_0_c2026_es_craft_personal_use_only_no_redistribution";


    // 上面
    for(let j=0;j<ys.length-1;j++){
      const y0 = ys[j], y1 = ys[j+1];
      for(let i=0;i<xs.length-1;i++){
        const x0 = xs[i], x1 = xs[i+1];
        quad(tris,
          {x:x0,y:y0,z:zTop[j][i]},
          {x:x1,y:y0,z:zTop[j][i+1]},
          {x:x1,y:y1,z:zTop[j+1][i+1]},
          {x:x0,y:y1,z:zTop[j+1][i]}
        );
      }
    }

    // 底面（逆巻き）
    for(let j=0;j<ys.length-1;j++){
      const y0 = ys[j], y1 = ys[j+1];
      for(let i=0;i<xs.length-1;i++){
        const x0 = xs[i], x1 = xs[i+1];
        quad(tris,
          {x:x0,y:y1,z:zBot[j+1][i]},
          {x:x1,y:y1,z:zBot[j+1][i+1]},
          {x:x1,y:y0,z:zBot[j][i+1]},
          {x:x0,y:y0,z:zBot[j][i]}
        );
      }
    }

    // 前面 y=0
    {
      const y = ys[0];
      for(let i=0;i<xs.length-1;i++){
        const x0 = xs[i], x1 = xs[i+1];
        quad(tris,
          {x:x0,y:y,z:zBot[0][i]},
          {x:x1,y:y,z:zBot[0][i+1]},
          {x:x1,y:y,z:zTop[0][i+1]},
          {x:x0,y:y,z:zTop[0][i]}
        );
      }
    }

    // 後面 y=D
    {
      const j = ys.length-1;
      const y = ys[j];
      for(let i=0;i<xs.length-1;i++){
        const x0 = xs[i], x1 = xs[i+1];
        quad(tris,
          {x:x0,y:y,z:zBot[j][i]},
          {x:x0,y:y,z:zTop[j][i]},
          {x:x1,y:y,z:zTop[j][i+1]},
          {x:x1,y:y,z:zBot[j][i+1]}
        );
      }
    }

    // 左面 x=0
    {
      const i = 0;
      for(let j=0;j<ys.length-1;j++){
        const y0 = ys[j], y1 = ys[j+1];
        quad(tris,
          {x:xs[i],y:y0,z:zBot[j][i]},
          {x:xs[i],y:y0,z:zTop[j][i]},
          {x:xs[i],y:y1,z:zTop[j+1][i]},
          {x:xs[i],y:y1,z:zBot[j+1][i]}
        );
      }
    }

    // 右面 x=W
    {
      const i = xs.length-1;
      for(let j=0;j<ys.length-1;j++){
        const y0 = ys[j], y1 = ys[j+1];
        quad(tris,
          {x:xs[i],y:y0,z:zBot[j][i]},
          {x:xs[i],y:y1,z:zBot[j+1][i]},
          {x:xs[i],y:y1,z:zTop[j+1][i]},
          {x:xs[i],y:y0,z:zTop[j][i]}
        );
      }
    }

    let stl = `solid ${name}\n`;
    for(const f of tris) stl += f;
    stl += `endsolid ${name}\n`;
    return stl;
  }

  /* ===================== actions ===================== */
  function doCalc(){
    const W  = Number($("W").value);
    const mL = Number($("mL").value);
    const mR = Number($("mR").value);

    const out = $("out");
    const wrap = $("templateWrap");

    try{
      if(!(W > 0)) throw new Error("ナット幅Wが不正です。");
      if(!(mL >= 0) || !(mR >= 0)) throw new Error("mL / mR が不正です。");

      const meta = parseDiametersWithMeta($("ds").value);
      const d = meta.mm;
      const n = d.length;

      const { x, g, x1, xn, err } = computeLayout(W, mL, mR, d);

      let s = "";
      s += `本数 n = ${n}\n`;
      s += `W=${mm2(W)} mm / mL=${mm2(mL)} mm / mR=${mm2(mR)} mm（端〜外周）\n`;
      s += `弦径(mm) = [${d.map(v=>mm2(v)).join(", ")}]\n\n`;
      s += `外周間の等間隔 g = ${mm2(g)} mm\n`;
      s += `外側弦中心: x1=${mm2(x1)} mm, xn=${mm2(xn)} mm\n`;
      s += `整合誤差 = ${err.toFixed(6)} mm\n\n`;

      const gd = Number($("gDepth").value);
      const minR = Math.min(...d.map(v=>v/2));
      if(gd < minR){
        s += `注意：gDepth=${mm2(gd)}mm は最小弦半径=${mm2(minR)}mm 未満のため、STL側では幅固定維持の都合で弦半径まで補正されます。\n\n`;
      }

      s += `--- 各弦中心位置 x（左端0基準, mm） ※表示は1弦=高音側 ---\n`;
      for(let i=n-1;i>=0;i--){
        const dispNo = (n - i);
        const dia = meta.isInchInput ? `${meta.rawTokens[i]}" / ${mm2(d[i])}mm` : `${mm2(d[i])}mm`;
        s += `${dispNo}弦: x=${mm2(x[i])}  d=${dia}\n`;
      }
      out.textContent = s;

      const svg = buildTemplateSVG(W, mL, mR, d, x, meta);
      wrap.innerHTML = svg;

      last = { W,mL,mR,d,x,meta,svg };
    }catch(e){
      out.textContent = "エラー: " + e.message;
      wrap.innerHTML = `<div class="muted">エラーでテンプレ生成できません</div>`;
      last = null;
    }
  }

  function openPDF(){
    if(!last){ alert("先に「計算」を実行してください。"); return; }
    const w = window.open("", "_blank", "width=950,height=750");
    if(!w){ alert("ポップアップがブロックされています。許可して再実行してください。"); return; }
    w.document.open();
    w.document.write('<!doctype html><html lang="ja"><head><meta charset="utf-8">');
    w.document.write('<title>Nut Template</title>');
    w.document.write('<style>@page{size:A4;margin:10mm;} body{margin:0;font-family:system-ui,sans-serif;}</style>');
    w.document.write('</head><body>');
    w.document.write(last.svg);
    w.document.write('</body></html>');
    w.document.close();
  }

  function exportCombSTL(){
    if(!last){ alert("先に「計算」を実行してください。"); return; }
    try{
      const W = last.W;
      const R = Number($("fbR").value);
      const tMin = Number($("combThk").value);
      const L = Number($("combL").value);
      const notchDepth = Number($("notchD").value);
      const slotW = Number($("slotW").value);
      const dxMax = Number($("dx").value);
      const xCenters = last.x.slice();

      const stl = generateCombSTL({W, L, R, tMin, notchDepth, slotW, dxMax, xCenters});
      const fn = `nut_comb_W${mm2(W)}_n${xCenters.length}_R${mm2(R)}_t${mm2(tMin)}.stl`;
      downloadText(fn, stl);
    }catch(e){
      alert("コームSTL生成エラー: " + e.message);
    }
  }

  function exportNutSTL(){
    if(!last){ alert("先に「計算」を実行してください。"); return; }
    try{
      const W = last.W;
      const D = Number($("nutD").value);
      const H = Number($("nutH").value);

      const topMode = $("topMode").value;
      const topR = Number($("topR").value);

      const bottomMode = $("bottomMode").value;
      const bottomR = Number($("bottomR").value);

      const C_front = Number($("cFront").value);
      const C_back  = Number($("cBack").value);

      const gDepth = Number($("gDepth").value);
      const dxy = Number($("nutDx").value);

      const stl = generateNutSTL({
        W, D, H,
        topMode, topR,
        bottomMode, bottomR,
        C_front, C_back,
        xCenters: last.x.slice(),
        dList: last.d.slice(),
        gDepth,
        dxy
      });

      const fn = `guide_nut_W${mm2(W)}_D${mm2(D)}_H${mm2(H)}_g${mm2(gDepth)}_Top${topMode==="flat"?"flat":("R"+mm2(topR))}_Bot${bottomMode==="flat"?"flat":("R"+mm2(bottomR))}_Cf${mm2(C_front)}_Cb${mm2(C_back)}_n${last.x.length}.stl`;
      downloadText(fn, stl);
    }catch(e){
      alert("ナットSTL生成エラー: " + e.message);
    }
  }

  window.addEventListener("DOMContentLoaded", () => {
    $("btnCalc").addEventListener("click", doCalc);
    $("btnPDF").addEventListener("click", openPDF);
    $("btnSTLComb").addEventListener("click", exportCombSTL);
    $("btnSTLNut").addEventListener("click", exportNutSTL);

    $("preset").addEventListener("change", () => {
      const key = $("preset").value;
      if(key) $("ds").value = PRESETS[key].text;
    });
    $("btnApplyPreset").addEventListener("click", applyPreset);

    $("fbR").addEventListener("change", () => $("bottomR").value = $("fbR").value);
  });

})();
</script>

</body>
</html>
